#!/usr/bin/python

#### measure

def measure(response_seconds=1, header=None, content=None, method='GET', url=None):

    import gevent, time
    from requests import request

    headers = dict()
    for name_value in (header or ()):
        try:
            name, value = name_value.split(':', 1)
        except ValueError:
            exit("Invalid header: '{header}'".format(header=name_value))
        headers[name] = value

    def task():
        start = time.time()
        #print(start)
        response = request(headers=headers, data=content, method=method, url=url)
        response.content # Time content transmition too.
        this_response_seconds = time.time() - start
        #print(this_response_seconds)
        is_success = response.ok
        is_quick = (this_response_seconds <= response_seconds)
        if is_success and is_quick:
            return True
        else:
            errors = []
            if not is_success:
                errors.append('Failed: {status_code} {reason}, {content}'.format(status_code=response.status_code, reason=response.reason, content=response.content))
            if not is_quick:
                errors.append('Slow: {this_response_seconds} seconds.'.format(this_response_seconds=this_response_seconds))
            return '\n'.join(errors)

    concurrency = 0
    ok = True
    while ok:
        concurrency += 1
        print(concurrency)
        workers = [gevent.spawn(task) for _ in xrange(concurrency)]
        gevent.joinall(workers)
        for worker in workers:
            result = worker.get()
            if result == True:
                continue
            print(result)
            ok = False

#### main

def main():

    #### parse command line arguments

    from argparse import ArgumentParser, RawTextHelpFormatter
    args_parser = ArgumentParser(
        description='Web load test measuring how many concurrent users will get response to their actions quickly - within a second.',
        epilog='''
Criterion:
    Maximal number of concurrent requests to the slowest URL
    while each request gets successful response within a second.

webqresp version 0.1.0
Copyright (C) 2013 by Denis Ryzhkov <denisr@denisr.com>
MIT License, see http://opensource.org/licenses/MIT
''',
        formatter_class=RawTextHelpFormatter,
    )
    args_parser.add_argument('--response-seconds', type=float, default=1, help='Maximal response time in seconds for each request to pass the test. Default: 1 second.')
    args_parser.add_argument('--header', action='append', help="Additional headers, e.g. --header='Content-Type: application/json' --header='X-Name: Value'.")
    args_parser.add_argument('--content', help='''Content for POST, etc. E.g. 'name1=value1&name2=value2' or '{"name1": "value1", "name2": "value2"}'.''')
    args_parser.add_argument('--method', default='GET', help='HTTP Method. Default: GET.')
    args_parser.add_argument('url', help='URL to test, e.g. http://example.com/some/page')
    args = args_parser.parse_args()

    #### become cooperative

    import gevent.monkey
    gevent.monkey.patch_all()

    #### measure

    measure(**vars(args))

if __name__ == '__main__':
    main()
